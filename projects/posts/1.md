# PCD8544 Component for ESP-IDF

<div class="image-gallery">

![image](/img/pcd8544/1.jpg)
![image](/img/pcd8544/2.jpg)

</div>

# Overview of the project

The PCD8544 is a LCD display driver found in the Nokia 5110 LCD. The ESP32 Integrated Developer Framework (ESP-IDF) is a toolchain framework used to build software for the ESP32 line of MCUs. It offers a greater deal of control and in my opinion a pretty neat menuconfig option that reduces the abstractions found in other editors which helps myself understand more of the fundamental ideas and what is actually happening to achieve my compiled code. Also I'll always find an excuse to use a cli.


There are plenty of drivers already written specifically for the PCD8544 and the ESP IDF and plentty supporting the arduino. The only real differance between them is the SPI interface between the device and the PCD8544. 

See below some links to other drivers:

- [yanbe's implemntation](https://github.com/yanbe/esp32-pcd8544) (ESP-IDF)
- [Adafruit implemntation](https://github.com/adafruit/Adafruit-PCD8544-Nokia-5110-LCD-library) (Arduino)
- []() (ESP-IDF)


# Basics of a dispaly driver


# Image of the screen and a graph of numbers
#    -> Use illustrator or photoshop

[image]() 

Displays can be daunting but essentially for a monochromatic display it's just a 2D array/matrix of on and off values. We store this array in a framebuffer, then send that framebuffer to the display IC over an SPI interface.

Below is an example of a frame buffer.

```C
boolean frame_buffer[] = {
    0, 0, 0, 0, 1, 0, 0,
    1, 1, 1, 0, 1, 0, 0,
    0, 0, 1, 0, 1, 0, 0,
    1, 1, 1, 0, 1, 0, 1,
    0, 0, 0, 0, 0, 0, 1
};
```

Now we have a data structure to work with we can now flip a pixel on or off.

```C
// Turn a pixel on for at a position within the frame buffer
frame_buffer[col * row] = 1; 

// Write the frame buffer.
draw_frame_buffer();
```

Sweet now we're set. We have the basic building block to do anything. 

Now there is more to a screen than just sending the frame buffer with the PCD8544 there are two modes as with most LCDs: Command and Data (C/D) commonly denoted on pin outs as DC.

If we take a look at the [PCD8544 Datasheet](https://voidstudios.com.au/pdf/pcd8544.pdf) on page 14 we can see all of the instructions availble. See the D/C command we can see what insturctions are commands and which are for sending data.

So our screen takes commands to let it do things like invert display, set the start address for the x and y pages/coordinates, etc. While our data is for writing the actual pixels to the screen. 


# Wire up

To connect the ESP32 and the Nokia 5110 LCD follow this diagram below. 

[image]()

Now in the pcd8544.h header file we can define the pins.

```C

```


# Creating a SPI connection within the ESP IDF Environment

First of let's create a function definition in the pcd8544.h file:

```C
spi_device_handle_t init_spi();
```

Now in the pcd8544.c file we can actually start implementing this functions.

```C
spi_device_handle_t init_spi() {
    // Create a new device handle
    spi_device_handle_t temp;

    // Bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = MOSI,
        .miso_io_num = -1,
        .sclk_io_num = SCLK,
    };

    // SPI interface config
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 4000000, // 4Mhz
        .mode = 0,
        .spics_io_num = -1, // Not using CS
        .queue_size = QUEUE_SIZE
    };

    // Setup and return the spi interface
    ESP_ERROR_CHECK( spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO) );
    ESP_ERROR_CHECK( spi_bus_add_device(SPI2_HOST, &devcfg, &temp) );

    return temp;
}   

``` 

### Bus Configuration

So first of all we setup the buscfg. We set the mosi_io_num -> Master Out Slave In, so the pin where our master (ESP32) will output to our slave (pcd8544) input. Set miso_io_num to -1 because we won't be reading from the pcd8544 device. The sclk_io_num is the serial clock pin.

### SPI Interface Configuration

Now we can create an SPI interface configuration using our bus configuration. The clock_speed_hz is our the clock for the SPI connection, if we look at the [PCD8544 Datasheet](https://www.voidstudios.com.au/pdf/pcd8544.pdf) we can see it supports a max clock speed of 4MHz. The mode set to 3 (CHECK THE DATASHEET AND MES -> !!!!!!!!!!!!!!!!!!!!!!! See how clcok pulsing and data works)

### Setup SPI

The last step is to actaully initialise and add the device to the temp spi_device_handle_t and return it back.


## Sending SPI Data

So now we have our SPI connection setup we can now send some data and commands to it. First of let's create the send_command function definition in the pcd8544.h file:

```
// Send a command
void send_command(uint8_t command) {
    // Set DC Low
    gpio_set_level(DC, 0);

    // Create a transaction
    spi_transaction_t trans;
    memset( &trans, 0, sizeof( spi_transaction_t ) );
    trans.length = 8;
    trans.tx_buffer = &command;
    ESP_ERROR_CHECK( spi_device_transmit(handle, &trans)  );

}
```

So going over we set the pin of the DC pin to low to signify we are about to send a command. We set this pin up later in the Initialising the PCD8544 LCD section.

Then we create a new spi transaction, by declaring a new variable of type spi_transaction_t, we then set all the data in the spi_transaction_t to 0 ensuring that it is initialised to their default state. we set the length to 8 bits one byte, we assign the transaction transmit buffer to the command we want to send which is an unit8_t just a byte.

Finally we transmit the SPI transaction.


Now that we can send a command we can send some data which is the same thing except we are setting the DC pin to HIGH | 1.

We could combine these functions and have another parameter denoting whether this is a data or command, but I like the readability in the rest of the code with this approach.

```C
// Send some data
void send_data(uint8_t data) {
     // Set DC Low
    gpio_set_level(DC, 1);

    // Create a transaction
    spi_transaction_t trans;
    memset( &trans, 0, sizeof( spi_transaction_t ) );
    trans.length = 8;
    trans.tx_buffer = &data;
    ESP_ERROR_CHECK( spi_device_transmit(handle, &trans)  );
}
```

## Initialising the PCD8544 LCD

Now in the pcd8544.c file let's take a look at the init_pcd8544() function implementation:

```C
// Init the LCD
void init_pcd8544() {
    esp_log_level_set(PCD_TAG, ESP_LOG_INFO);

    // Init SPI
    handle = init_spi();

     // Setup the pins for output mode
    gpio_set_direction(RESET, GPIO_MODE_OUTPUT);
    gpio_set_direction(DC, GPIO_MODE_OUTPUT);

    // Reset the dispaly
    gpio_set_level(RESET, 1);
    gpio_set_level(RESET, 0);
    gpio_set_level(RESET, 1);

    // Set the contrast
    set_contrast(30);

    // Set the Voltage Bias
    send_command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
    send_command(PCD8544_SETBIAS | 0x07); // Bias
    send_command(PCD8544_FUNCTIONSET);

    // Sets the LCD to normal mode
    send_command( PCD8544_FUNCTIONSET);

    // Set the display to Normal mode
    send_command( PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);

    // Draws the first frame
    draw_frame_buffer();
}
```


So first up we use the the init_spi() function to return us an spi_handle_t so we can write data over SPI.

Next up we setup the GPIO pins for the Reset pin and the Data/Command (DC) Pin. Setting their direction to GPIO_MODE_OUTPUT an ESP32 const for denoting this pin is for writing not reading.

Then we toggle the reset pin on and off and back to on to reset the PCD8544.

Next we use another function called set_contrast() which is just a helper function that fires some send_commands to the device that set the contrast.

Then we set the voltage bias by sending some commands.

THen we send the functionset command to the pcd8544 to let it know what function set to exepect.

Then we set the display control mode to normal.

Then finally we draw the frame buffer. Which is just whatever the framebuffer is initially set as, in this case the VOID logo as a bitmap.

Let's look at how we can draw the frame buffer. First of all lets define the draw_frame_buffer() function in the header file pcd8544.h:

```C
void draw_frame_buffer();
```

Now let's add the implementation in the pcd8544.c file:

```C
// Frame Buffer.
uint8_t buffer [LCD_WIDTH * LCD_HEIGHT / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x80, 0x00, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xfe, 0x0f, 0x07, 0xfe, 0xfe, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x0e, 0x0e, 0xfe, 0xfe, 0xfc, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0x7f, 0xf0, 0xe0, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x70, 0x70, 0x7f, 0x7f, 0x3f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };

// Drwa the frame buffer
void draw_frame_buffer() {
    send_command(PCD8544_SETYADDR | 0);
    send_command(PCD8544_SETXADDR | 0);

    // So there are 6 rows and 84 columns
    for (int page = 0; page < (6 * 84); page++) {
        send_data(buffer[page]);
    }
}
```

So first of all we define our frame buffer. In the case of our display we have a 48x84 pixel display that is split up into pages of 8 bits. The paging setup is best described through an illustraion see below.

[image]()

In this case I've just set a bitmap of the VOID logo.

Next up we can actually send the framebuffer to the device in 1 byte chunks.

So first we set the x and y address of the display. From there we can loop through all the pages of the device and send 1 byte to the device.

If you want you could add a little delay within each iteration of the for loop to see how each page is drawn.


## Drawing Lines

## Drawing Circles

## Drawing Bitmaps

## Writing Text to Screens

## Scrolling Text

## Animating Bitmaps

## Future additions and considerations

## Wrap up
